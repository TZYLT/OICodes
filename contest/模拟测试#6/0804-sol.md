### T1

注意到 $f(xy)=f(x)+f(y)$，故 $f(g(i))=f(\prod\limits_{j\mid i}j)=\sum\limits_{j\mid i}f(j)$，答案就可以写成 $\sum\limits_{i=1}^nf(i)\lfloor\dfrac{n}{i}\rfloor$。求单个 $f(i)$ 就线性筛的时候顺带着筛出每个数的最小质因子 $mnp_i$，这样就每次快速除掉 $i$ 的最小质因子即可完成 $i$ 的质因数分解，进而算出 $f(i)$。

### T2

加强自 CF367E。

首先，$n>m$ 时候答案一定为 $0$，而因为 $nm\le 10^5$，故可以得出 $n\le\sqrt{10^5}$。

从左到右轮廓线 dp，设 $dp_{i,j,k}$ 表示考虑到前 $i$ 个位置，总共有 $j$ 个区间左端点 $\le i$，有 $k$ 个区间右端点 $\le i$ 的方案数，转移分是否在 $i+1$ 处放置左端点、是否在 $i+1$ 处放置右端点总共四种情况进行转移。

时间复杂度 $O(n^2m)$。

### T3

先考虑测试点 7\~11 的做法，因为 $a_i$ 比较大，可以枚举 $\lfloor\dfrac{y}{a_i}\rfloor$ 的值 $k$，那么因为 $\lfloor\dfrac{y}{i}\rfloor$ 的值随着 $i$ 的增加是单调不降的，故满足 $\lfloor\dfrac{y}{a_i}\rfloor=k$ 的 $a_i$ 必定落在一段区间内，假设这段区间为 $[l,r]$。因为 $\lfloor\dfrac{y}{a_i}\rfloor+y\bmod a_i=k+y-ka_i$，因此要快速统计这些 $a_i$ 的贡献之和，需要维护两个以值域为下标的树状数组，一个支持求出值落在一段区间内的 $a_i$ 的个数，一个支持求出值落在一段区间内的 $a_i$ 之和，这样即可快速算出贡献。

将上述做法使用整出分块维护，可以得到一个 $O(n\sqrt{n}\log n)$ 的做法，获得 85 分。

注意到查询次数为 $O(n\sqrt{n})$ 但修改次数只有 $O(\sqrt{n})$，故使用修改 $O(\sqrt{n})$ 查询 $O(1)$ 的分块可做到 $O(n\sqrt{n})$。

### T4

先考虑给定 $S$ 以后怎么算 $f(S)$，我们考虑以 $1$ 为根 DFS 一遍整棵树，然后考虑贪心。每次贪心地找到所有路径中 LCA 最深的路径，如果这条路径上所有节点都没被访问过我们就将该路径上所有节点都设为被访问过并令答案加一，否则我们直接不管这条路径。

考虑方案数转期望，我们求出每个点有多大概率作为某个被选择路径的 LCA 出现过，然后把它们加起来再乘上 $2^{\frac{n(n+1)}{2}}$ 就是答案。那么怎么求呢？注意到对于一个点如果它的某个祖先被访问了，那么这个点也没有用了。因此我们可以将选择一条路径视作直接将这个子树吃掉，这样就可以 DP 了，我们设 $dp_{u,j}$ 表示钦定了 LCA 在 $u$ 子树内的路径，还有 $j$ 个点没有被吃掉的概率，转移就将两个子树合并起来即可，设 $u$ 为 $v$ 的父亲，那么显然 $dp_{u,0}$ 只能转移到新的 $dp_{u,0}$，而对于 $i\ne 0$，$j\in[0,siz_y]$，$dp_{u,i}$ 和 $dp_{v,j}$ 有 $\dfrac{1}{2^{ij}}$ 的概率转移到 $dp_{u,i+j}$，有 $1-\dfrac{1}{2^{ij}}$ 的概率转移到 $dp_{u,0}$。树上背包求一下即可。最终 $dp_{i,0}$ 即为 $i$ 作为某条路径 LCA 出现的概率。时间复杂度 $\mathcal O(n^2)$。